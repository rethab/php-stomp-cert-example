{"name":"php-stomp-cert-example","tagline":"An example project demonstrating the PHP Stomp library with SSL Certificates","body":"The current version of the PHP Stomp library uses the function fsockopen, which\r\nmakes it impossible to send a certificate. On top of that, PHP does not verify\r\ncertificates of peers by default in versions before PHP 5.6.\r\n\r\nThis project aims to demonstrate how a modified version of the PHP Stomp library\r\nmay be used to communicate securely with a message broker. As an example,\r\nActiveMQ has been used, but this would really work with any broker that supports\r\nStomp.\r\n\r\nBy securely, I mean the client verifies the certificate of the server. And, a\r\nclient certificate is used for authentication.\r\n\r\n\r\n## Related Linkes\r\n* PHP TLS Peer Verification RFC: https://wiki.php.net/rfc/tls-peer-verification\r\n* ActiveMQ Documentation: http://activemq.apache.org/getting-started.html\r\n\r\n## Step by Step\r\n\r\n### Active MQ Certificate\r\n1. Download ActiveMQ from the official website and unpack it\r\n2. Delete the original keystore and truststore (conf/broker.{k,t}s)\r\n3. Create a new Keystore with a key using keytool (comes with JDK)\r\n   1. `keytool -genkey -keyalg RSA -alias broker -keystore broker.ks -validity 365 -keysize 2048`\r\n4. Set it in the activemq config (conf/activemq.xml). The truststore is\r\n   configured here as well. We are going to create it with the client\r\n   certificate though.\r\n    ```<sslContext>\r\n           <sslContext keyStore=\"file:${activemq.base}/conf/broker.ks/\"\r\n            keyStorePassword=\"broker\"\r\n            trustStore=\"file:${activemq.base}/conf/broker.ts/\"\r\n            trustStorePassword=\"broker\" />\r\n       </sslContext>\r\n    ```\r\n\r\n### PHP Client Certificate\r\n1. Create a keypair for the client\r\n   * `openssl genrsa -des3 -out php-client.key 2048`\r\n2. Create a signing request\r\n   * `openssl req -new -key php-client.key -out php-client.csr`\r\n3. We remove the password from the client for convenience. We could have left it\r\n   encrypted and tell PHP the password with the ssl context parameters.\r\n   * `openssl rsa -in php-client.key -out php-client.key`\r\n4. Self-sign the certificate signing request (the CSR is not required anymore after this step)\r\n   * `openssl x509 -req -days 365 -in php-client.csr -signkey php-client.key -out php-client.crt`\r\n5. The following command imports the certificate of the php-client into the\r\n   broker's truststore. It is perfectly fine to use an existing keystore, but\r\n   you might want to have control over whom you trust and therefore create a new\r\n   one. If the specified truststore does not exist, it is created (it will thus\r\n   ask you for a password).\r\n   * `keytool -import -file php-client.crt -alias php-client -keystore path/to/activemq/conf/broker.ts`\r\n\r\n### ActiveMQ Configuration\r\n1. First of all, we need to tell ActiveMQ that we are going to authenticate users\r\n   based on their certificate. Although topics (and queues) are created lazily,\r\n   we want to authorize the groups to read and/or write on certain queues rather\r\n   than just granting global write access. The following configuration snipped\r\n   tells it to use the users.properties and groups.properties in combination\r\n   with certificates. Place this in login.config:\r\n    ```\r\n    activemq-certificate {\r\n        org.apache.activemq.jaas.TextFileCertificateLoginModule\r\n            required\r\n            org.apache.activemq.jaas.textfiledn.user=\"users.properties\"\r\n            org.apache.activemq.jaas.textfiledn.group=\"groups.properties\";\r\n    };\r\n    ```\r\n2. Next up, let us map the certificate information to a username. The following\r\n   line ought to be placed in the file users.properties and tells ActiveMQ to\r\n   map a request with the following certificate information to the user php-client.\r\n   Note that not just anybody could send a certificate with this information,\r\n   since we imported the certificate into the truststore beforehand and only that\r\n   one will be accepted.\r\n    `php-client=CN=PHP Test, OU=Engineering, O=Company Test, L=Location Test, ST=State Test, C=US`\r\n3. ActiveMQ gives permissions on topics and queues to groups, which is why we\r\n   also need to create a group for our new user. The following line adds our\r\n   user php-client to the group php-client. Note that, if the group should have\r\n   more than one user, separate them with a comma. gropus.properties:\r\n    `php-client=php-client`\r\n4. We now tell ActiveMQ to use the configuration 'activemq-certificate' (as\r\n   defined in login.config) with the 'jaasCertificateAuthenticationPlugin' and\r\n   then setup the authorizationMap. We basically allow our members of the group\r\n   php-client to create the queue (admin), because we will create it when we\r\n   send the first message, and members of the group php-client are allowed to\r\n   write to it. Besides, we also need to grant the php-client group admin\r\n   privileges on the advisory topics ('>' is a wildcard). Read more about\r\n   advisory topics in the ActiveMQ manual.\r\n    ```\r\n    <plugins>\r\n        <jaasCertificateAuthenticationPlugin configuration=\"activemq-certificate\"/>\r\n        <authorizationPlugin>\r\n            <map>\r\n                <authorizationMap>\r\n                    <authorizationEntries>\r\n                        <authorizationEntry topic=\"TestQueue\" admin=\"php-client\" write=\"php-client\" />\r\n                        <authorizationEntry topic=\"ActiveMQ.Advisory.>\" admin=\"php-client\" />\r\n                    </authorizationEntries>\r\n                </authorizationMap>\r\n            </map>\r\n        </authorizationPlugin>\r\n    </plugins>\r\n    ```\r\n5. Finally, we configure the stomp connect in the activemq.xml accordingly.\r\n   Suffix the URI part of the transport connector entry scheme with '+ssl' and add a\r\n   needClientAuth to the parameters of the URI such that it now looks like this:\r\n   `<transportConnector name=\"stomp\" uri=\"stomp+ssl://0.0.0.0:61613?needClientAuth=true&amp;maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>`\r\n\r\n### PHP Client Code\r\nNow that we have both the certificate of ActiveMQ (the only one we are going to\r\naccept as our peer) as well as a certificate we are going to use on the client\r\nside (and ActiveMQ knows about it by means of the trust store), we can put\r\ntogether the client side code to send a message to ActiveMQ from PHP.\r\n1. PHP needs a concatenanted file starting with the private key\r\n   followed by the certificate. Note that if you have a certificate hierarchy, all intermediate\r\n   certificates including the root CA itself must be part of this file as well.\r\n   * `cat php-client.key php-client.crt > php-client-chain.pem`\r\n   * Or, alternatively (with intermediate certificates):\r\n         `cat php-client.key php-client.crt intermediate.crt rootca.crt > php-client-chain.pem`\r\n2. We use the certficate of the broker directly from the PHP side rather than\r\n   using a common CA. For that, we need to export the certificate in the correct\r\n   format from the broker's keystore (note the '-rfc' option):\r\n   `keytool -export -rfc -alias broker.ks -keystore conf/broker.ks file broker.crt`\r\n3. Now we can pass these two files as ssl context parameters to stomp using the\r\n   following array:\r\n   ```\r\n   $opts = array(\r\n        'ssl' => array(\r\n            'local_cert' => './php-client-chain.pem',\r\n            'cafile' => './broker.crt',\r\n            'verify_peer' => true,\r\n        )\r\n    );\r\n   ```\r\n4. Finally, we can send the message to stomp:\r\n   ```\r\n   $con = new FuseSource\\Stomp\\Stomp('ssl://localhost:61613', $opts);\r\n   $con->connect();\r\n\r\n   $body = json_encode(array('message' => array('content' => 'hello, world')));\r\n   $headers = array('persistent' => 'true');\r\n   var_dump($con->send('/topic/TestQueue', $body, $headers));\r\n   ```\r\n\r\n## Debugging\r\n- Connect to the server and get the server certificate chain as well as the\r\n  potentially accepted certificates from a client. You should see the\r\n  certificate your previously put into the truststore:\r\n  `openssl s_client -connect localhost:61613 -cert php-client-chain.pem -debug -showcerts`\r\n- Is the certficiate in the correct format? Try to parse it with the following\r\n  two functions and look at the output (with, e.g. var_dump):\r\n  `openssl_x509_parse(file_get_contents('./file.crt'))`\r\n","google":"UA-50286462-1","note":"Don't delete this file! It's used internally to help with page regeneration."}